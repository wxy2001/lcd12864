C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE OS_CORE
OBJECT MODULE PLACED IN .\OutPut\OS_CORE.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uCosii\OS_CORE.C LARGE OPTIMIZE(8,SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\OutPut\OS_CORE.lst) TABS(2) OBJECT(.\OutPut\OS_CORE.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                             CORE FUNCTIONS
   6          *
   7          *                          (c) Copyright 1992-2001, Jean J. Labrosse, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File : OS_CORE.C
  11          * By   : Jean J. Labrosse
  12          *********************************************************************************************************
  13          */
  14          
  15          #ifndef  OS_MASTER_FILE
  16          #define  OS_GLOBALS
  17          #include "source\includes.h"
  18          #endif
  19          
  20          /*
  21          *********************************************************************************************************
  22          *                              MAPPING TABLE TO MAP BIT POSITION TO BIT MASK
  23          *
  24          * Note: Index into table is desired bit position, 0..7
  25          *       Indexed value corresponds to bit mask
  26          *********************************************************************************************************
  27          */
  28          
  29          INT8U  code  OSMapTbl[]   = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
  30          
  31          /*
  32          *********************************************************************************************************
  33          *                                       PRIORITY RESOLUTION TABLE
  34          *
  35          * Note: Index into table is bit pattern to resolve highest priority
  36          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
  37          *********************************************************************************************************
  38          */
  39          
  40          INT8U  code  OSUnMapTbl[] = {
  41              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  43              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  45              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  47              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  49              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  51              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  53              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 2   

  55              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  56              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
  57          };
  58          /*$PAGE*/
  59          /*
  60          *********************************************************************************************************
  61          *                                             INITIALIZATION
  62          *
  63          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
  64          *              creating any uC/OS-II object and, prior to calling OSStart().
  65          *
  66          * Arguments  : none
  67          *
  68          * Returns    : none
  69          *********************************************************************************************************
  70          */
  71          
  72          void  OSInit (void) reentrant
  73          {
  74   1          INT16U     i;
  75   1          INT8U     *prdytbl;
  76   1          OS_TCB    *ptcb1;
  77   1          OS_TCB    *ptcb2;
  78   1      #if (OS_EVENT_EN > 0) && (OS_MAX_EVENTS > 1)
                  OS_EVENT  *pevent1;
                  OS_EVENT  *pevent2;
              #endif
  82   1      
  83   1      
  84   1      #if OS_VERSION >= 204
  85   1          OSInitHookBegin();                                           /* Call port specific initialization code
             -   */
  86   1      #endif
  87   1      
  88   1      #if OS_TIME_GET_SET_EN > 0   
                  OSTime        = 0L;                                          /* Clear the 32-bit system clock         
             -   */
              #endif
  91   1          OSIntNesting  = 0;                                           /* Clear the interrupt nesting counter   
             -   */
  92   1          OSLockNesting = 0;                                           /* Clear the scheduling lock counter     
             -   */
  93   1          OSTaskCtr     = 0;                                           /* Clear the number of tasks             
             -   */
  94   1          OSRunning     = FALSE;                                       /* Indicate that multitasking not started
             -   */
  95   1          OSIdleCtr     = 0L;                                          /* Clear the 32-bit idle counter         
             -   */
  96   1      #if (OS_TASK_STAT_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
                  OSIdleCtrRun  = 0L;
                  OSIdleCtrMax  = 0L;
                  OSStatRdy     = FALSE;                                       /* Statistic task is not ready           
             -   */
              #endif
 101   1          OSCtxSwCtr    = 0;                                           /* Clear the context switch counter      
             -   */
 102   1          OSRdyGrp      = 0x00;                                        /* Clear the ready list                  
             -   */
 103   1          prdytbl       = &OSRdyTbl[0];
 104   1          for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 105   2              *prdytbl++ = 0x00;
 106   2          }
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 3   

 107   1      
 108   1          OSPrioCur     = 0;
 109   1          OSPrioHighRdy = 0;
 110   1          OSTCBHighRdy  = (OS_TCB *)0;                                 /* TCB Initialization                    
             -   */
 111   1          OSTCBCur      = (OS_TCB *)0;
 112   1          OSTCBList     = (OS_TCB *)0;
 113   1          for (i = 0; i < (OS_LOWEST_PRIO + 1); i++) {                 /* Clear the priority table              
             -   */
 114   2              OSTCBPrioTbl[i] = (OS_TCB *)0;
 115   2          }
 116   1          ptcb1 = &OSTCBTbl[0];
 117   1          ptcb2 = &OSTCBTbl[1];
 118   1          for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs               
             -   */
 119   2              ptcb1->OSTCBNext = ptcb2;
 120   2              ptcb1++;
 121   2              ptcb2++;
 122   2          }
 123   1          ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                           
             -   */
 124   1          OSTCBFreeList    = &OSTCBTbl[0];
 125   1      
 126   1      #if (OS_EVENT_EN > 0) && (OS_MAX_EVENTS > 0)
                  #if OS_MAX_EVENTS == 1                                       
                  OSEventFreeList              = &OSEventTbl[0];               /* Only have ONE event control block     
             -   */
                  OSEventFreeList->OSEventType = OS_EVENT_TYPE_UNUSED;
                  OSEventFreeList->OSEventPtr  = (OS_EVENT *)0;
                  #else
                  pevent1 = &OSEventTbl[0];
                  pevent2 = &OSEventTbl[1];
                  for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {                  /* Init. list of free EVENT control block
             -s  */
                      pevent1->OSEventType = OS_EVENT_TYPE_UNUSED;
                      pevent1->OSEventPtr  = pevent2;
                      pevent1++;
                      pevent2++;
                  }
                  pevent1->OSEventType = OS_EVENT_TYPE_UNUSED;
                  pevent1->OSEventPtr  = (OS_EVENT *)0;
                  OSEventFreeList      = &OSEventTbl[0];
                  #endif
              #endif
 145   1      
 146   1      #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
                  OS_FlagInit();                                               /* Initialize the event flag structures  
             -   */
              #endif
 149   1      
 150   1      #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
                  OS_QInit();                                                  /* Initialize the message queue structure
             -s  */
              #endif
 153   1      
 154   1      #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
                  OS_MemInit();                                                /* Initialize the memory manager         
             -   */
              #endif
 157   1      
 158   1          /* ------------------------------------- CREATION OF 'IDLE' TASK -------------------------------------
             --- */
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 4   

 159   1      #if OS_TASK_CREATE_EXT_EN > 0
                  #if OS_STK_GROWTH == 1
                  (void)OSTaskCreateExt(OS_TaskIdle,
                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle
             -() */
                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                  
             -   */
                                        OS_IDLE_PRIO,                              /* Lowest priority level             
             -   */
                                        OS_TASK_IDLE_ID,
                                        &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack               
             -   */
                                        OS_TASK_IDLE_STK_SIZE,
                                        (void *)0,                                 /* No TCB extension                  
             -   */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stac
             -k  */
                  #else
                  (void)OSTaskCreateExt(OS_TaskIdle,
                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle
             -() */
                                        &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                  
             -   */
                                        OS_IDLE_PRIO,                              /* Lowest priority level             
             -   */
                                        OS_TASK_IDLE_ID,
                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack               
             -   */
                                        OS_TASK_IDLE_STK_SIZE,
                                        (void *)0,                                 /* No TCB extension                  
             -   */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stac
             -k  */
                  #endif
              #else
 182   1          #if OS_STK_GROWTH == 1
                  (void)OSTaskCreate(OS_TaskIdle,
                                     (void *)0,
                                     &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
                                     OS_IDLE_PRIO);
                  #else
 188   1          (void)OSTaskCreate(OS_TaskIdle,
 189   1                             (void *)0,
 190   1                             &OSTaskIdleStk[0],
 191   1                             OS_IDLE_PRIO);
 192   1          #endif
 193   1      #endif
 194   1      
 195   1          /* ------------------------------- CREATION OF 'STATISTIC' TASK ---------------------------------- */
 196   1      #if OS_TASK_STAT_EN > 0
                  #if OS_TASK_CREATE_EXT_EN > 0
                      #if OS_STK_GROWTH == 1
                      (void)OSTaskCreateExt(OS_TaskStat,
                                            (void *)0,                                   /* No args passed to OS_TaskSta
             -t()*/
                                            &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack            
             -   */
                                            OS_STAT_PRIO,                                /* One higher than the idle tas
             -k  */
                                            OS_TASK_STAT_ID,
                                            &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack         
             -   */
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 5   

                                            OS_TASK_STAT_STK_SIZE,
                                            (void *)0,                                   /* No TCB extension            
             -   */
                                            OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clea
             -r  */
                      #else
                      (void)OSTaskCreateExt(OS_TaskStat,
                                            (void *)0,                                   /* No args passed to OS_TaskSta
             -t()*/
                                            &OSTaskStatStk[0],                           /* Set Top-Of-Stack            
             -   */
                                            OS_STAT_PRIO,                                /* One higher than the idle tas
             -k  */
                                            OS_TASK_STAT_ID,
                                            &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack         
             -   */
                                            OS_TASK_STAT_STK_SIZE,
                                            (void *)0,                                   /* No TCB extension            
             -   */
                                            OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clea
             -r  */
                      #endif
                  #else
                      #if OS_STK_GROWTH == 1
                      (void)OSTaskCreate(OS_TaskStat,
                                         (void *)0,                                      /* No args passed to OS_TaskSta
             -t()*/
                                         &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack            
             -   */
                                         OS_STAT_PRIO);                                  /* One higher than the idle tas
             -k  */
                      #else
                      (void)OSTaskCreate(OS_TaskStat,
                                         (void *)0,                                      /* No args passed to OS_TaskSta
             -t()*/
                                         &OSTaskStatStk[0],                              /* Set Top-Of-Stack            
             -   */
                                         OS_STAT_PRIO);                                  /* One higher than the idle tas
             -k  */
                      #endif
                  #endif
              #endif
 233   1      
 234   1      #if OS_VERSION >= 204
 235   1          OSInitHookEnd();                                                       /* Call port specific init. cod
             -e  */
 236   1      #endif
 237   1      }
 238          /*$PAGE*/
 239          /*
 240          *********************************************************************************************************
 241          *                                              ENTER ISR
 242          *
 243          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
 244          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
 245          *              only perform rescheduling at the last nested ISR.
 246          *
 247          * Arguments  : none
 248          *
 249          * Returns    : none
 250          *
 251          * Notes      : 1) Your ISR can directly increment OSIntNesting without calling this function because
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 6   

 252          *                 OSIntNesting has been declared 'global'.  You MUST, however, be sure that the increment
 253          *                 is performed 'indivisibly' by your processor to ensure proper access to this critical
 254          *                 resource.
 255          *              2) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
 256          *              3) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
 257          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
 258          *                 end of the ISR.
 259          *********************************************************************************************************
 260          */
 261          
 262          void  OSIntEnter (void) reentrant
 263          {
 264   1      #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif    
 267   1          
 268   1          
 269   1          OS_ENTER_CRITICAL();
 270   1          if (OSIntNesting < 255) {
 271   2              OSIntNesting++;                          /* Increment ISR nesting level                        */
 272   2          }
 273   1          OS_EXIT_CRITICAL();
 274   1      }
 275          /*$PAGE*/
 276          /*
 277          *********************************************************************************************************
 278          *                                               EXIT ISR
 279          *
 280          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
 281          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
 282          *              a new, high-priority task, is ready to run.
 283          *
 284          * Arguments  : none
 285          *
 286          * Returns    : none
 287          *
 288          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
 289          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
 290          *                 end of the ISR.
 291          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
 292          *********************************************************************************************************
 293          */
 294          
 295          void  OSIntExit (void) reentrant
 296          {
 297   1      #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
                  OS_CPU_SR  cpu_sr;
              #endif
 300   1          
 301   1          
 302   1          OS_ENTER_CRITICAL();
 303   1          if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping           */
 304   2              OSIntNesting--;
 305   2          }
 306   1          if ((OSIntNesting == 0) && (OSLockNesting == 0)) { /* Reschedule only if all ISRs complete ...     */
 307   2              OSIntExitY    = OSUnMapTbl[OSRdyGrp];          /* ... and not locked.                          */
 308   2              OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
 309   2              if (OSPrioHighRdy != OSPrioCur) {              /* No Ctx Sw if current task is highest rdy     */
 310   3                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 311   3                  OSCtxSwCtr++;                              /* Keep track of the number of context switches */
 312   3                  OSIntCtxSw();                              /* Perform interrupt level context switch       */
 313   3              }
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 7   

 314   2          }
 315   1          OS_EXIT_CRITICAL();
 316   1      }
 317          /*$PAGE*/
 318          /*
 319          *********************************************************************************************************
 320          *                                          PREVENT SCHEDULING
 321          *
 322          * Description: This function is used to prevent rescheduling to take place.  This allows your application
 323          *              to prevent context switches until you are ready to permit context switching.
 324          *
 325          * Arguments  : none
 326          *
 327          * Returns    : none
 328          *
 329          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
 330          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
 331          *********************************************************************************************************
 332          */
 333          
 334          #if OS_SCHED_LOCK_EN > 0
              void  OSSchedLock (void) reentrant
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif    
                  
                  
                  if (OSRunning == TRUE) {                     /* Make sure multitasking is running                  */
                      OS_ENTER_CRITICAL();
                      if (OSLockNesting < 255) {               /* Prevent OSLockNesting from wrapping back to 0      */
                          OSLockNesting++;                     /* Increment lock nesting level                       */
                      }
                      OS_EXIT_CRITICAL();
                  }
              }
              #endif    
 351          
 352          /*$PAGE*/
 353          /*
 354          *********************************************************************************************************
 355          *                                          ENABLE SCHEDULING
 356          *
 357          * Description: This function is used to re-allow rescheduling.
 358          *
 359          * Arguments  : none
 360          *
 361          * Returns    : none
 362          *
 363          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
 364          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
 365          *********************************************************************************************************
 366          */
 367          
 368          #if OS_SCHED_LOCK_EN > 0
              void  OSSchedUnlock (void) reentrant
              {
              #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR  cpu_sr;
              #endif    
                  
                  
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 8   

                  if (OSRunning == TRUE) {                                   /* Make sure multitasking is running    */
                      OS_ENTER_CRITICAL();
                      if (OSLockNesting > 0) {                               /* Do not decrement if already 0        */
                          OSLockNesting--;                                   /* Decrement lock nesting level         */
                          if ((OSLockNesting == 0) && (OSIntNesting == 0)) { /* See if sched. enabled and not an ISR */
                              OS_EXIT_CRITICAL();
                              OS_Sched();                                    /* See if a HPT is ready                */
                          } else {
                              OS_EXIT_CRITICAL();
                          }
                      } else {
                          OS_EXIT_CRITICAL();
                      }
                  }
              }
              #endif    
 392          
 393          /*$PAGE*/
 394          /*
 395          *********************************************************************************************************
 396          *                                          START MULTITASKING
 397          *
 398          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
 399          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
 400          *              and you MUST have created at least one task.
 401          *
 402          * Arguments  : none
 403          *
 404          * Returns    : none
 405          *
 406          * Note       : OSStartHighRdy() MUST:
 407          *                 a) Call OSTaskSwHook() then,
 408          *                 b) Set OSRunning to TRUE.
 409          *********************************************************************************************************
 410          */
 411          
 412          void  OSStart (void) reentrant
 413          {
 414   1          INT8U y;
 415   1          INT8U x;
 416   1      
 417   1      
 418   1          if (OSRunning == FALSE) {
 419   2              y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
 420   2              x             = OSUnMapTbl[OSRdyTbl[y]];
 421   2              OSPrioHighRdy = (INT8U)((y << 3) + x);
 422   2              OSPrioCur     = OSPrioHighRdy;
 423   2              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 424   2              OSTCBCur      = OSTCBHighRdy;
 425   2              OSStartHighRdy();                            /* Execute target specific code to start task     */
 426   2          }
 427   1      }
 428          /*$PAGE*/
 429          /*
 430          *********************************************************************************************************
 431          *                                        STATISTICS INITIALIZATION
 432          *
 433          * Description: This function is called by your application to establish CPU usage by first determining
 434          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
 435          *              during that time.  CPU usage is then determined by a low priority task which keeps track
 436          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
 437          *              determined by:
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 9   

 438          *
 439          *                                             OSIdleCtr
 440          *                 CPU Usage (%) = 100 * (1 - ------------)
 441          *                                            OSIdleCtrMax
 442          *
 443          * Arguments  : none
 444          *
 445          * Returns    : none
 446          *********************************************************************************************************
 447          */
 448          
 449          #if OS_TASK_STAT_EN > 0
              void  OSStatInit (void) reentrant
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif    
                  
                  
                  OSTimeDly(2);                                /* Synchronize with clock tick                        */
                  OS_ENTER_CRITICAL();
                  OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
                  OS_EXIT_CRITICAL();
                  OSTimeDly(OS_TICKS_PER_SEC);                 /* Determine MAX. idle counter value for 1 second     */
                  OS_ENTER_CRITICAL();
                  OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1 second       */
                  OSStatRdy    = TRUE;
                  OS_EXIT_CRITICAL();
              }
              #endif
 468          /*$PAGE*/
 469          /*
 470          *********************************************************************************************************
 471          *                                         PROCESS SYSTEM TICK
 472          *
 473          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
 474          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
 475          *              called by a high priority task.
 476          *
 477          * Arguments  : none
 478          *
 479          * Returns    : none
 480          *********************************************************************************************************
 481          */
 482          
 483          void  OSTimeTick (void) reentrant
 484          {
 485   1      #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR  cpu_sr;
              #endif    
 488   1          OS_TCB    *ptcb;
 489   1      
 490   1      
 491   1          OSTimeTickHook();                                      /* Call user definable hook                 */
 492   1      #if OS_TIME_GET_SET_EN > 0   
                  OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter           */
                  OSTime++;
                  OS_EXIT_CRITICAL();
              #endif    
 497   1          ptcb = OSTCBList;                                      /* Point at first TCB in TCB list           */
 498   1          while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {              /* Go through all TCBs in TCB list          */
 499   2              OS_ENTER_CRITICAL();
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 10  

 500   2              if (ptcb->OSTCBDly != 0) {                         /* Delayed or waiting for event with TO     */
 501   3                  if (--ptcb->OSTCBDly == 0) {                   /* Decrement nbr of ticks to end of delay   */
 502   4                      if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == 0x00) {   /* Is task suspended?             */
 503   5                          OSRdyGrp               |= ptcb->OSTCBBitY; /* No,  Make task Rdy to Run (timed out)*/
 504   5                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 505   5                      } else {                                       /* Yes, Leave 1 tick to prevent ...     */
 506   5                          ptcb->OSTCBDly = 1;                        /* ... loosing the task when the ...    */
 507   5                      }                                              /* ... suspension is removed.           */
 508   4                  }
 509   3              }
 510   2              ptcb = ptcb->OSTCBNext;                                /* Point at next TCB in TCB list        */
 511   2              OS_EXIT_CRITICAL();
 512   2          }
 513   1      }
 514          /*$PAGE*/
 515          /*
 516          *********************************************************************************************************
 517          *                                             GET VERSION
 518          *
 519          * Description: This function is used to return the version number of uC/OS-II.  The returned value
 520          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
 521          *              would be returned as 200.
 522          *
 523          * Arguments  : none
 524          *
 525          * Returns    : the version number of uC/OS-II multiplied by 100.
 526          *********************************************************************************************************
 527          */
 528          
 529          #if OS_VERSION_EN > 0
              INT16U  OSVersion (void) reentrant
              {
                  return (OS_VERSION);
              }
              #endif
 535          
 536          /*$PAGE*/
 537          /*
 538          *********************************************************************************************************
 539          *                                            DUMMY FUNCTION
 540          *
 541          * Description: This function doesn't do anything.  It is called by OSTaskDel().
 542          *
 543          * Arguments  : none
 544          *
 545          * Returns    : none
 546          *********************************************************************************************************
 547          */
 548          
 549          #if OS_TASK_DEL_EN > 0
              void  OS_Dummy (void) reentrant
              {
              }
              #endif
 554          
 555          /*$PAGE*/
 556          /*
 557          *********************************************************************************************************
 558          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
 559          *
 560          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
 561          *              waiting for an event to occur.
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 11  

 562          *
 563          * Arguments  : pevent    is a pointer to the event control block corresponding to the event.
 564          *
 565          *              msg       is a pointer to a message.  This pointer is used by message oriented services
 566          *                        such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
 567          *                        service functions.
 568          *
 569          *              msk       is a mask that is used to clear the status byte of the TCB.  For example,
 570          *                        OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
 571          *
 572          * Returns    : none
 573          *
 574          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
 575          *********************************************************************************************************
 576          */
 577          #if OS_EVENT_EN > 0
              INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk) reentrant
              {
                  OS_TCB *ptcb;
                  INT8U   x;
                  INT8U   y;
                  INT8U   bitx;
                  INT8U   bity;
                  INT8U   prio;
              
              
                  y    = OSUnMapTbl[pevent->OSEventGrp];            /* Find highest prio. task waiting for message   */
                  bity = OSMapTbl[y];
                  x    = OSUnMapTbl[pevent->OSEventTbl[y]];
                  bitx = OSMapTbl[x];
                  prio = (INT8U)((y << 3) + x);                     /* Find priority of task getting the msg         */
                  if ((pevent->OSEventTbl[y] &= ~bitx) == 0x00) {   /* Remove this task from the waiting list        */
                      pevent->OSEventGrp &= ~bity;                  /* Clr group bit if this was only task pending   */
                  }
                  ptcb                 =  OSTCBPrioTbl[prio];       /* Point to this task's OS_TCB                   */
                  ptcb->OSTCBDly       =  0;                        /* Prevent OSTimeTick() from readying task       */
                  ptcb->OSTCBEventPtr  = (OS_EVENT *)0;             /* Unlink ECB from this task                     */
              #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
                  ptcb->OSTCBMsg       = msg;                       /* Send message directly to waiting task         */
              #else
                  msg                  = msg;                       /* Prevent compiler warning if not used          */
              #endif
                  ptcb->OSTCBStat     &= ~msk;                      /* Clear bit associated with event type          */
                  if (ptcb->OSTCBStat == OS_STAT_RDY) {             /* See if task is ready (could be susp'd)        */
                      OSRdyGrp        |=  bity;                     /* Put task in the ready to run list             */
                      OSRdyTbl[y]     |=  bitx;
                  }
                  return (prio);
              }
              #endif
 612          /*$PAGE*/
 613          /*
 614          *********************************************************************************************************
 615          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
 616          *
 617          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
 618          *              not occurred.
 619          *
 620          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
 621          *
 622          * Returns    : none
 623          *
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 12  

 624          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
 625          *********************************************************************************************************
 626          */
 627          #if OS_EVENT_EN > 0
              void  OS_EventTaskWait (OS_EVENT *pevent) reentrant
              {
                  OSTCBCur->OSTCBEventPtr = pevent;            /* Store pointer to event control block in TCB        */
                  if ((OSRdyTbl[OSTCBCur->OSTCBY] &= ~OSTCBCur->OSTCBBitX) == 0x00) {   /* Task no longer ready      */
                      OSRdyGrp &= ~OSTCBCur->OSTCBBitY;        /* Clear event grp bit if this was only task pending  */
                  }
                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
              }
              #endif
 638          /*$PAGE*/
 639          /*
 640          *********************************************************************************************************
 641          *                              MAKE TASK READY TO RUN BASED ON EVENT TIMEOUT
 642          *
 643          * Description: This function is called by other uC/OS-II services to make a task ready to run because a
 644          *              timeout occurred.
 645          *
 646          * Arguments  : pevent   is a pointer to the event control block which is readying a task.
 647          *
 648          * Returns    : none
 649          *
 650          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
 651          *********************************************************************************************************
 652          */
 653          #if OS_EVENT_EN > 0
              void  OS_EventTO (OS_EVENT *pevent) reentrant
              {
                  if ((pevent->OSEventTbl[OSTCBCur->OSTCBY] &= ~OSTCBCur->OSTCBBitX) == 0x00) {
                      pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
                  }
                  OSTCBCur->OSTCBStat     = OS_STAT_RDY;       /* Set status to ready                                */
                  OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /* No longer waiting for event                        */
              }
              #endif
 663          /*$PAGE*/
 664          /*
 665          *********************************************************************************************************
 666          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
 667          *
 668          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
 669          *
 670          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
 671          *
 672          * Returns    : none
 673          *
 674          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
 675          *********************************************************************************************************
 676          */
 677          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0) || (OS_SEM_EN > 0) || (OS_MUTEX_EN > 0)
              void  OS_EventWaitListInit (OS_EVENT *pevent) reentrant
              {
                  INT8U  *ptbl;
              
              
                  pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
                  ptbl               = &pevent->OSEventTbl[0];
              
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 13  

              #if OS_EVENT_TBL_SIZE > 0
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 1
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 2
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 3
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 4
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 5
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 6
                  *ptbl++            = 0x00;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 7
                  *ptbl              = 0x00;
              #endif
              }
              #endif
 719          /*$PAGE*/
 720          /*
 721          *********************************************************************************************************
 722          *                                              SCHEDULER
 723          *
 724          * Description: This function is called by other uC/OS-II services to determine whether a new, high
 725          *              priority task has been made ready to run.  This function is invoked by TASK level code
 726          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
 727          *
 728          * Arguments  : none
 729          *
 730          * Returns    : none
 731          *
 732          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
 733          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
 734          *********************************************************************************************************
 735          */
 736          
 737          void  OS_Sched (void) reentrant
 738          {
 739   1      #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
                  OS_CPU_SR  cpu_sr;
              #endif    
 742   1          INT8U      y;
 743   1      
 744   1      
 745   1          OS_ENTER_CRITICAL();
 746   1          if ((OSIntNesting == 0) && (OSLockNesting == 0)) { /* Sched. only if all ISRs done & not locked    */
 747   2              y             = OSUnMapTbl[OSRdyGrp];          /* Get pointer to HPT ready to run              */
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 14  

 748   2              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 749   2              if (OSPrioHighRdy != OSPrioCur) {              /* No Ctx Sw if current task is highest rdy     */
 750   3                  OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 751   3                  OSCtxSwCtr++;                              /* Increment context switch counter             */
 752   3                  OS_TASK_SW();                              /* Perform a context switch                     */
 753   3              }
 754   2          }
 755   1          OS_EXIT_CRITICAL();
 756   1      }
 757          /*$PAGE*/
 758          /*
 759          *********************************************************************************************************
 760          *                                              IDLE TASK
 761          *
 762          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
 763          *              executes because they are ALL waiting for event(s) to occur.
 764          *
 765          * Arguments  : none
 766          *
 767          * Returns    : none
 768          *
 769          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
 770          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
 771          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
 772          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
 773          *                 interrupts.
 774          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve 
 775          *                 power.
 776          *********************************************************************************************************
 777          */
 778          
 779          void  OS_TaskIdle (void *ppdata) reentrant
 780          {
 781   1      #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif    
 784   1          
 785   1          
 786   1          ppdata = ppdata;                               /* Prevent compiler warning for not using 'ppdata'     
             -*/
 787   1          for (;;) {
 788   2              OS_ENTER_CRITICAL();
 789   2              OSIdleCtr++;
 790   2              OS_EXIT_CRITICAL();
 791   2              OSTaskIdleHook();                        /* Call user definable HOOK                           */
 792   2          }
 793   1      }
 794          /*$PAGE*/
 795          /*
 796          *********************************************************************************************************
 797          *                                            STATISTICS TASK
 798          *
 799          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
 800          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
 801          *              CPU usage is determined by:
 802          *
 803          *                                          OSIdleCtr
 804          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
 805          *                                         OSIdleCtrMax
 806          *
 807          * Arguments  : ppdata     this pointer is not used at this time.
 808          *
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 15  

 809          * Returns    : none
 810          *
 811          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
 812          *                 next higher priority, OS_IDLE_PRIO-1.
 813          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
 814          *              3) We delay for 5 seconds in the beginning to allow the system to reach steady state and
 815          *                 have all other tasks created before we do statistics.  You MUST have at least a delay
 816          *                 of 2 seconds to allow for the system to establish the maximum value for the idle
 817          *                 counter.
 818          *********************************************************************************************************
 819          */
 820          
 821          #if OS_TASK_STAT_EN > 0
              void  OS_TaskStat (void *ppdata) reentrant
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif    
                  INT32U     run;
                  INT8S      usage;
              
              
                  ppdata = ppdata;                             /* Prevent compiler warning for not using 'ppdata'     */
                  while (OSStatRdy == FALSE) {
                      OSTimeDly(2 * OS_TICKS_PER_SEC);         /* Wait until statistic task is ready                 */
                  }
                  for (;;) {
                      OS_ENTER_CRITICAL();
                      OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
                      run          = OSIdleCtr;
                      OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
                      OS_EXIT_CRITICAL();
                      if (OSIdleCtrMax > 0L) {
                          usage = (INT8S)(100L - 100L * run / OSIdleCtrMax);
                          if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
                              OSCPUUsage = usage;
                          } else {
                              OSCPUUsage = 0;
                          }
                      } else {
                          OSCPUUsage = 0;
                      }
                      OSTaskStatHook();                        /* Invoke user definable hook                         */
                      OSTimeDly(OS_TICKS_PER_SEC);             /* Accumulate OSIdleCtr for the next second           */
                  }
              }
              #endif
 856          /*$PAGE*/
 857          /*
 858          *********************************************************************************************************
 859          *                                            INITIALIZE TCB
 860          *
 861          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
 862          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
 863          *
 864          * Arguments  : prio          is the priority of the task being created
 865          *
 866          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
 867          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
 868          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
 869          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
 870          *                            specific.
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 16  

 871          *
 872          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
 873          *                            'OSTaskCreate()'.
 874          *
 875          *              id            is the task's ID (0..65535)
 876          *
 877          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
 878          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
 879          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
 880          *                            units are established by the #define constant OS_STK which is CPU
 881          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
 882          *
 883          *              pext          is a pointer to a user supplied memory area that is used to extend the task
 884          *                            control block.  This allows you to store the contents of floating-point
 885          *                            registers, MMU registers or anything else you could find useful during a
 886          *                            context switch.  You can even assign a name to each task and store this name
 887          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
 888          *
 889          *              opt           options as passed to 'OSTaskCreateExt()' or,
 890          *                            0 if called from 'OSTaskCreate()'.
 891          *
 892          * Returns    : OS_NO_ERR         if the call was successful
 893          *              OS_NO_MORE_TCB    if there are no more free TCBs to be allocated and thus, the task cannot
 894          *                                be created.
 895          *
 896          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
 897          *********************************************************************************************************
 898          */
 899          
 900          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U 
             -opt) reentrant
 901          {
 902   1      #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR  cpu_sr;
              #endif    
 905   1          OS_TCB    *ptcb;
 906   1      
 907   1      
 908   1          OS_ENTER_CRITICAL();
 909   1          ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 910   1          if (ptcb != (OS_TCB *)0) {
 911   2              OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
 912   2              OS_EXIT_CRITICAL();
 913   2              ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
 914   2              ptcb->OSTCBPrio      = (INT8U)prio;                /* Load task priority into TCB              */
 915   2              ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
 916   2              ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
 917   2      
 918   2      #if OS_TASK_CREATE_EXT_EN > 0
                      ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
                      ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
                      ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
                      ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
                      ptcb->OSTCBId        = id;                         /* Store task ID                            */
              #else
 925   2              pext                 = pext;                       /* Prevent compiler warning if not used     */
 926   2              stk_size             = stk_size;
 927   2              pbos                 = pbos;
 928   2              opt                  = opt;
 929   2              id                   = id;
 930   2      #endif
 931   2      
C51 COMPILER V9.57.0.0   OS_CORE                                                           06/08/2022 11:54:36 PAGE 17  

 932   2      #if OS_TASK_DEL_EN > 0
                      ptcb->OSTCBDelReq    = OS_NO_ERR;
              #endif
 935   2      
 936   2              ptcb->OSTCBY         = prio >> 3;                  /* Pre-compute X, Y, BitX and BitY          */
 937   2              ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
 938   2              ptcb->OSTCBX         = prio & 0x07;
 939   2              ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
 940   2      
 941   2      #if OS_EVENT_EN > 0
                      ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
              #endif
 944   2      
 945   2      #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
                      ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
              #endif
 948   2      
 949   2      #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
                      ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
              #endif
 952   2      
 953   2      #if OS_VERSION >= 204
 954   2              OSTCBInitHook(ptcb);
 955   2      #endif
 956   2      
 957   2              OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 958   2              
 959   2              OS_ENTER_CRITICAL();
 960   2              OSTCBPrioTbl[prio] = ptcb;
 961   2              ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 962   2              ptcb->OSTCBPrev    = (OS_TCB *)0;
 963   2              if (OSTCBList != (OS_TCB *)0) {
 964   3                  OSTCBList->OSTCBPrev = ptcb;
 965   3              }
 966   2              OSTCBList               = ptcb;
 967   2              OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 968   2              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 969   2              OS_EXIT_CRITICAL();
 970   2              return (OS_NO_ERR);
 971   2          }
 972   1          OS_EXIT_CRITICAL();
 973   1          return (OS_NO_MORE_TCB);
 974   1      }
*** WARNING C294 IN LINE 793 OF uCosii\OS_CORE.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1563    ----
   CONSTANT SIZE    =    264    ----
   XDATA SIZE       =    252    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     46    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
